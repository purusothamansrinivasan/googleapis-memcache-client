/*
 * Cloud Memorystore for Memcached API
 * Google Cloud Memorystore for Memcached API is used for creating and managing Memcached instances in GCP.
 *
 * The version of the OpenAPI document: v1beta2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.client.model.GoogleCloudMemcacheV1beta2MaintenancePolicy;
import org.openapitools.client.model.InstanceMessage;
import org.openapitools.client.model.MaintenanceSchedule;
import org.openapitools.client.model.MemcacheParameters;
import org.openapitools.client.model.Node;
import org.openapitools.client.model.NodeConfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * A Memorystore for Memcached instance
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-25T15:33:03.624322+05:30[Asia/Kolkata]", comments = "Generator version: 7.15.0")
public class Instance {
  public static final String SERIALIZED_NAME_AUTHORIZED_NETWORK = "authorizedNetwork";
  @SerializedName(SERIALIZED_NAME_AUTHORIZED_NETWORK)
  @javax.annotation.Nullable
  private String authorizedNetwork;

  public static final String SERIALIZED_NAME_CREATE_TIME = "createTime";
  @SerializedName(SERIALIZED_NAME_CREATE_TIME)
  @javax.annotation.Nullable
  private String createTime;

  public static final String SERIALIZED_NAME_DISCOVERY_ENDPOINT = "discoveryEndpoint";
  @SerializedName(SERIALIZED_NAME_DISCOVERY_ENDPOINT)
  @javax.annotation.Nullable
  private String discoveryEndpoint;

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "displayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  @javax.annotation.Nullable
  private String displayName;

  public static final String SERIALIZED_NAME_INSTANCE_MESSAGES = "instanceMessages";
  @SerializedName(SERIALIZED_NAME_INSTANCE_MESSAGES)
  @javax.annotation.Nullable
  private List<InstanceMessage> instanceMessages = new ArrayList<>();

  public static final String SERIALIZED_NAME_LABELS = "labels";
  @SerializedName(SERIALIZED_NAME_LABELS)
  @javax.annotation.Nullable
  private Map<String, String> labels = new HashMap<>();

  public static final String SERIALIZED_NAME_MAINTENANCE_POLICY = "maintenancePolicy";
  @SerializedName(SERIALIZED_NAME_MAINTENANCE_POLICY)
  @javax.annotation.Nullable
  private GoogleCloudMemcacheV1beta2MaintenancePolicy maintenancePolicy;

  public static final String SERIALIZED_NAME_MAINTENANCE_SCHEDULE = "maintenanceSchedule";
  @SerializedName(SERIALIZED_NAME_MAINTENANCE_SCHEDULE)
  @javax.annotation.Nullable
  private MaintenanceSchedule maintenanceSchedule;

  public static final String SERIALIZED_NAME_MEMCACHE_FULL_VERSION = "memcacheFullVersion";
  @SerializedName(SERIALIZED_NAME_MEMCACHE_FULL_VERSION)
  @javax.annotation.Nullable
  private String memcacheFullVersion;

  public static final String SERIALIZED_NAME_MEMCACHE_NODES = "memcacheNodes";
  @SerializedName(SERIALIZED_NAME_MEMCACHE_NODES)
  @javax.annotation.Nullable
  private List<Node> memcacheNodes = new ArrayList<>();

  /**
   * The major version of Memcached software. If not provided, latest supported version will be used. Currently the latest supported major version is &#x60;MEMCACHE_1_5&#x60;. The minor version will be automatically determined by our system based on the latest supported minor version.
   */
  @JsonAdapter(MemcacheVersionEnum.Adapter.class)
  public enum MemcacheVersionEnum {
    MEMCACHE_VERSION_UNSPECIFIED("MEMCACHE_VERSION_UNSPECIFIED"),
    
    MEMCACHE_1_5("MEMCACHE_1_5"),
    
    MEMCACHE_1_6_15("MEMCACHE_1_6_15");

    private String value;

    MemcacheVersionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static MemcacheVersionEnum fromValue(String value) {
      for (MemcacheVersionEnum b : MemcacheVersionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<MemcacheVersionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MemcacheVersionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MemcacheVersionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return MemcacheVersionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      MemcacheVersionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_MEMCACHE_VERSION = "memcacheVersion";
  @SerializedName(SERIALIZED_NAME_MEMCACHE_VERSION)
  @javax.annotation.Nullable
  private MemcacheVersionEnum memcacheVersion;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  @javax.annotation.Nullable
  private String name;

  public static final String SERIALIZED_NAME_NODE_CONFIG = "nodeConfig";
  @SerializedName(SERIALIZED_NAME_NODE_CONFIG)
  @javax.annotation.Nullable
  private NodeConfig nodeConfig;

  public static final String SERIALIZED_NAME_NODE_COUNT = "nodeCount";
  @SerializedName(SERIALIZED_NAME_NODE_COUNT)
  @javax.annotation.Nullable
  private Integer nodeCount;

  public static final String SERIALIZED_NAME_PARAMETERS = "parameters";
  @SerializedName(SERIALIZED_NAME_PARAMETERS)
  @javax.annotation.Nullable
  private MemcacheParameters parameters;

  public static final String SERIALIZED_NAME_RESERVED_IP_RANGE_ID = "reservedIpRangeId";
  @SerializedName(SERIALIZED_NAME_RESERVED_IP_RANGE_ID)
  @javax.annotation.Nullable
  private List<String> reservedIpRangeId = new ArrayList<>();

  /**
   * Output only. The state of this Memcached instance.
   */
  @JsonAdapter(StateEnum.Adapter.class)
  public enum StateEnum {
    STATE_UNSPECIFIED("STATE_UNSPECIFIED"),
    
    CREATING("CREATING"),
    
    READY("READY"),
    
    UPDATING("UPDATING"),
    
    DELETING("DELETING"),
    
    PERFORMING_MAINTENANCE("PERFORMING_MAINTENANCE"),
    
    MEMCACHE_VERSION_UPGRADING("MEMCACHE_VERSION_UPGRADING");

    private String value;

    StateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StateEnum fromValue(String value) {
      for (StateEnum b : StateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATE = "state";
  @SerializedName(SERIALIZED_NAME_STATE)
  @javax.annotation.Nullable
  private StateEnum state;

  public static final String SERIALIZED_NAME_UPDATE_AVAILABLE = "updateAvailable";
  @SerializedName(SERIALIZED_NAME_UPDATE_AVAILABLE)
  @javax.annotation.Nullable
  private Boolean updateAvailable;

  public static final String SERIALIZED_NAME_UPDATE_TIME = "updateTime";
  @SerializedName(SERIALIZED_NAME_UPDATE_TIME)
  @javax.annotation.Nullable
  private String updateTime;

  public static final String SERIALIZED_NAME_ZONES = "zones";
  @SerializedName(SERIALIZED_NAME_ZONES)
  @javax.annotation.Nullable
  private List<String> zones = new ArrayList<>();

  public Instance() {
  }

  public Instance(
     String createTime, 
     String discoveryEndpoint, 
     String memcacheFullVersion, 
     List<Node> memcacheNodes, 
     StateEnum state, 
     Boolean updateAvailable, 
     String updateTime
  ) {
    this();
    this.createTime = createTime;
    this.discoveryEndpoint = discoveryEndpoint;
    this.memcacheFullVersion = memcacheFullVersion;
    this.memcacheNodes = memcacheNodes;
    this.state = state;
    this.updateAvailable = updateAvailable;
    this.updateTime = updateTime;
  }

  public Instance authorizedNetwork(@javax.annotation.Nullable String authorizedNetwork) {
    this.authorizedNetwork = authorizedNetwork;
    return this;
  }

  /**
   * The full name of the Google Compute Engine [network](https://cloud.google.com/vpc/docs/vpc) to which the instance is connected. If left unspecified, the &#x60;default&#x60; network will be used.
   * @return authorizedNetwork
   */
  @javax.annotation.Nullable
  public String getAuthorizedNetwork() {
    return authorizedNetwork;
  }

  public void setAuthorizedNetwork(@javax.annotation.Nullable String authorizedNetwork) {
    this.authorizedNetwork = authorizedNetwork;
  }


  /**
   * Output only. The time the instance was created.
   * @return createTime
   */
  @javax.annotation.Nullable
  public String getCreateTime() {
    return createTime;
  }



  /**
   * Output only. Endpoint for the Discovery API.
   * @return discoveryEndpoint
   */
  @javax.annotation.Nullable
  public String getDiscoveryEndpoint() {
    return discoveryEndpoint;
  }



  public Instance displayName(@javax.annotation.Nullable String displayName) {
    this.displayName = displayName;
    return this;
  }

  /**
   * User provided name for the instance, which is only used for display purposes. Cannot be more than 80 characters.
   * @return displayName
   */
  @javax.annotation.Nullable
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(@javax.annotation.Nullable String displayName) {
    this.displayName = displayName;
  }


  public Instance instanceMessages(@javax.annotation.Nullable List<InstanceMessage> instanceMessages) {
    this.instanceMessages = instanceMessages;
    return this;
  }

  public Instance addInstanceMessagesItem(InstanceMessage instanceMessagesItem) {
    if (this.instanceMessages == null) {
      this.instanceMessages = new ArrayList<>();
    }
    this.instanceMessages.add(instanceMessagesItem);
    return this;
  }

  /**
   * List of messages that describe the current state of the Memcached instance.
   * @return instanceMessages
   */
  @javax.annotation.Nullable
  public List<InstanceMessage> getInstanceMessages() {
    return instanceMessages;
  }

  public void setInstanceMessages(@javax.annotation.Nullable List<InstanceMessage> instanceMessages) {
    this.instanceMessages = instanceMessages;
  }


  public Instance labels(@javax.annotation.Nullable Map<String, String> labels) {
    this.labels = labels;
    return this;
  }

  public Instance putLabelsItem(String key, String labelsItem) {
    if (this.labels == null) {
      this.labels = new HashMap<>();
    }
    this.labels.put(key, labelsItem);
    return this;
  }

  /**
   * Resource labels to represent user-provided metadata. Refer to cloud documentation on labels for more details. https://cloud.google.com/compute/docs/labeling-resources
   * @return labels
   */
  @javax.annotation.Nullable
  public Map<String, String> getLabels() {
    return labels;
  }

  public void setLabels(@javax.annotation.Nullable Map<String, String> labels) {
    this.labels = labels;
  }


  public Instance maintenancePolicy(@javax.annotation.Nullable GoogleCloudMemcacheV1beta2MaintenancePolicy maintenancePolicy) {
    this.maintenancePolicy = maintenancePolicy;
    return this;
  }

  /**
   * Get maintenancePolicy
   * @return maintenancePolicy
   */
  @javax.annotation.Nullable
  public GoogleCloudMemcacheV1beta2MaintenancePolicy getMaintenancePolicy() {
    return maintenancePolicy;
  }

  public void setMaintenancePolicy(@javax.annotation.Nullable GoogleCloudMemcacheV1beta2MaintenancePolicy maintenancePolicy) {
    this.maintenancePolicy = maintenancePolicy;
  }


  public Instance maintenanceSchedule(@javax.annotation.Nullable MaintenanceSchedule maintenanceSchedule) {
    this.maintenanceSchedule = maintenanceSchedule;
    return this;
  }

  /**
   * Get maintenanceSchedule
   * @return maintenanceSchedule
   */
  @javax.annotation.Nullable
  public MaintenanceSchedule getMaintenanceSchedule() {
    return maintenanceSchedule;
  }

  public void setMaintenanceSchedule(@javax.annotation.Nullable MaintenanceSchedule maintenanceSchedule) {
    this.maintenanceSchedule = maintenanceSchedule;
  }


  /**
   * Output only. The full version of memcached server running on this instance. System automatically determines the full memcached version for an instance based on the input MemcacheVersion. The full version format will be \&quot;memcached-1.5.16\&quot;.
   * @return memcacheFullVersion
   */
  @javax.annotation.Nullable
  public String getMemcacheFullVersion() {
    return memcacheFullVersion;
  }



  /**
   * Output only. List of Memcached nodes. Refer to Node message for more details.
   * @return memcacheNodes
   */
  @javax.annotation.Nullable
  public List<Node> getMemcacheNodes() {
    return memcacheNodes;
  }



  public Instance memcacheVersion(@javax.annotation.Nullable MemcacheVersionEnum memcacheVersion) {
    this.memcacheVersion = memcacheVersion;
    return this;
  }

  /**
   * The major version of Memcached software. If not provided, latest supported version will be used. Currently the latest supported major version is &#x60;MEMCACHE_1_5&#x60;. The minor version will be automatically determined by our system based on the latest supported minor version.
   * @return memcacheVersion
   */
  @javax.annotation.Nullable
  public MemcacheVersionEnum getMemcacheVersion() {
    return memcacheVersion;
  }

  public void setMemcacheVersion(@javax.annotation.Nullable MemcacheVersionEnum memcacheVersion) {
    this.memcacheVersion = memcacheVersion;
  }


  public Instance name(@javax.annotation.Nullable String name) {
    this.name = name;
    return this;
  }

  /**
   * Required. Unique name of the resource in this scope including project and location using the form: &#x60;projects/{project_id}/locations/{location_id}/instances/{instance_id}&#x60; Note: Memcached instances are managed and addressed at the regional level so &#x60;location_id&#x60; here refers to a Google Cloud region; however, users may choose which zones Memcached nodes should be provisioned in within an instance. Refer to zones field for more details.
   * @return name
   */
  @javax.annotation.Nullable
  public String getName() {
    return name;
  }

  public void setName(@javax.annotation.Nullable String name) {
    this.name = name;
  }


  public Instance nodeConfig(@javax.annotation.Nullable NodeConfig nodeConfig) {
    this.nodeConfig = nodeConfig;
    return this;
  }

  /**
   * Get nodeConfig
   * @return nodeConfig
   */
  @javax.annotation.Nullable
  public NodeConfig getNodeConfig() {
    return nodeConfig;
  }

  public void setNodeConfig(@javax.annotation.Nullable NodeConfig nodeConfig) {
    this.nodeConfig = nodeConfig;
  }


  public Instance nodeCount(@javax.annotation.Nullable Integer nodeCount) {
    this.nodeCount = nodeCount;
    return this;
  }

  /**
   * Required. Number of nodes in the Memcached instance.
   * @return nodeCount
   */
  @javax.annotation.Nullable
  public Integer getNodeCount() {
    return nodeCount;
  }

  public void setNodeCount(@javax.annotation.Nullable Integer nodeCount) {
    this.nodeCount = nodeCount;
  }


  public Instance parameters(@javax.annotation.Nullable MemcacheParameters parameters) {
    this.parameters = parameters;
    return this;
  }

  /**
   * Get parameters
   * @return parameters
   */
  @javax.annotation.Nullable
  public MemcacheParameters getParameters() {
    return parameters;
  }

  public void setParameters(@javax.annotation.Nullable MemcacheParameters parameters) {
    this.parameters = parameters;
  }


  public Instance reservedIpRangeId(@javax.annotation.Nullable List<String> reservedIpRangeId) {
    this.reservedIpRangeId = reservedIpRangeId;
    return this;
  }

  public Instance addReservedIpRangeIdItem(String reservedIpRangeIdItem) {
    if (this.reservedIpRangeId == null) {
      this.reservedIpRangeId = new ArrayList<>();
    }
    this.reservedIpRangeId.add(reservedIpRangeIdItem);
    return this;
  }

  /**
   * Optional. Contains the id of allocated IP address ranges associated with the private service access connection for example, \&quot;test-default\&quot; associated with IP range 10.0.0.0/29.
   * @return reservedIpRangeId
   */
  @javax.annotation.Nullable
  public List<String> getReservedIpRangeId() {
    return reservedIpRangeId;
  }

  public void setReservedIpRangeId(@javax.annotation.Nullable List<String> reservedIpRangeId) {
    this.reservedIpRangeId = reservedIpRangeId;
  }


  /**
   * Output only. The state of this Memcached instance.
   * @return state
   */
  @javax.annotation.Nullable
  public StateEnum getState() {
    return state;
  }



  /**
   * Output only. Returns true if there is an update waiting to be applied
   * @return updateAvailable
   */
  @javax.annotation.Nullable
  public Boolean getUpdateAvailable() {
    return updateAvailable;
  }



  /**
   * Output only. The time the instance was updated.
   * @return updateTime
   */
  @javax.annotation.Nullable
  public String getUpdateTime() {
    return updateTime;
  }



  public Instance zones(@javax.annotation.Nullable List<String> zones) {
    this.zones = zones;
    return this;
  }

  public Instance addZonesItem(String zonesItem) {
    if (this.zones == null) {
      this.zones = new ArrayList<>();
    }
    this.zones.add(zonesItem);
    return this;
  }

  /**
   * Zones in which Memcached nodes should be provisioned. Memcached nodes will be equally distributed across these zones. If not provided, the service will by default create nodes in all zones in the region for the instance.
   * @return zones
   */
  @javax.annotation.Nullable
  public List<String> getZones() {
    return zones;
  }

  public void setZones(@javax.annotation.Nullable List<String> zones) {
    this.zones = zones;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Instance instance = (Instance) o;
    return Objects.equals(this.authorizedNetwork, instance.authorizedNetwork) &&
        Objects.equals(this.createTime, instance.createTime) &&
        Objects.equals(this.discoveryEndpoint, instance.discoveryEndpoint) &&
        Objects.equals(this.displayName, instance.displayName) &&
        Objects.equals(this.instanceMessages, instance.instanceMessages) &&
        Objects.equals(this.labels, instance.labels) &&
        Objects.equals(this.maintenancePolicy, instance.maintenancePolicy) &&
        Objects.equals(this.maintenanceSchedule, instance.maintenanceSchedule) &&
        Objects.equals(this.memcacheFullVersion, instance.memcacheFullVersion) &&
        Objects.equals(this.memcacheNodes, instance.memcacheNodes) &&
        Objects.equals(this.memcacheVersion, instance.memcacheVersion) &&
        Objects.equals(this.name, instance.name) &&
        Objects.equals(this.nodeConfig, instance.nodeConfig) &&
        Objects.equals(this.nodeCount, instance.nodeCount) &&
        Objects.equals(this.parameters, instance.parameters) &&
        Objects.equals(this.reservedIpRangeId, instance.reservedIpRangeId) &&
        Objects.equals(this.state, instance.state) &&
        Objects.equals(this.updateAvailable, instance.updateAvailable) &&
        Objects.equals(this.updateTime, instance.updateTime) &&
        Objects.equals(this.zones, instance.zones);
  }

  @Override
  public int hashCode() {
    return Objects.hash(authorizedNetwork, createTime, discoveryEndpoint, displayName, instanceMessages, labels, maintenancePolicy, maintenanceSchedule, memcacheFullVersion, memcacheNodes, memcacheVersion, name, nodeConfig, nodeCount, parameters, reservedIpRangeId, state, updateAvailable, updateTime, zones);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Instance {\n");
    sb.append("    authorizedNetwork: ").append(toIndentedString(authorizedNetwork)).append("\n");
    sb.append("    createTime: ").append(toIndentedString(createTime)).append("\n");
    sb.append("    discoveryEndpoint: ").append(toIndentedString(discoveryEndpoint)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    instanceMessages: ").append(toIndentedString(instanceMessages)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    maintenancePolicy: ").append(toIndentedString(maintenancePolicy)).append("\n");
    sb.append("    maintenanceSchedule: ").append(toIndentedString(maintenanceSchedule)).append("\n");
    sb.append("    memcacheFullVersion: ").append(toIndentedString(memcacheFullVersion)).append("\n");
    sb.append("    memcacheNodes: ").append(toIndentedString(memcacheNodes)).append("\n");
    sb.append("    memcacheVersion: ").append(toIndentedString(memcacheVersion)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    nodeConfig: ").append(toIndentedString(nodeConfig)).append("\n");
    sb.append("    nodeCount: ").append(toIndentedString(nodeCount)).append("\n");
    sb.append("    parameters: ").append(toIndentedString(parameters)).append("\n");
    sb.append("    reservedIpRangeId: ").append(toIndentedString(reservedIpRangeId)).append("\n");
    sb.append("    state: ").append(toIndentedString(state)).append("\n");
    sb.append("    updateAvailable: ").append(toIndentedString(updateAvailable)).append("\n");
    sb.append("    updateTime: ").append(toIndentedString(updateTime)).append("\n");
    sb.append("    zones: ").append(toIndentedString(zones)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("authorizedNetwork", "createTime", "discoveryEndpoint", "displayName", "instanceMessages", "labels", "maintenancePolicy", "maintenanceSchedule", "memcacheFullVersion", "memcacheNodes", "memcacheVersion", "name", "nodeConfig", "nodeCount", "parameters", "reservedIpRangeId", "state", "updateAvailable", "updateTime", "zones"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(0);
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Instance
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Instance.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Instance is not found in the empty JSON string", Instance.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Instance.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Instance` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("authorizedNetwork") != null && !jsonObj.get("authorizedNetwork").isJsonNull()) && !jsonObj.get("authorizedNetwork").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `authorizedNetwork` to be a primitive type in the JSON string but got `%s`", jsonObj.get("authorizedNetwork").toString()));
      }
      if ((jsonObj.get("createTime") != null && !jsonObj.get("createTime").isJsonNull()) && !jsonObj.get("createTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createTime").toString()));
      }
      if ((jsonObj.get("discoveryEndpoint") != null && !jsonObj.get("discoveryEndpoint").isJsonNull()) && !jsonObj.get("discoveryEndpoint").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `discoveryEndpoint` to be a primitive type in the JSON string but got `%s`", jsonObj.get("discoveryEndpoint").toString()));
      }
      if ((jsonObj.get("displayName") != null && !jsonObj.get("displayName").isJsonNull()) && !jsonObj.get("displayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayName").toString()));
      }
      if (jsonObj.get("instanceMessages") != null && !jsonObj.get("instanceMessages").isJsonNull()) {
        JsonArray jsonArrayinstanceMessages = jsonObj.getAsJsonArray("instanceMessages");
        if (jsonArrayinstanceMessages != null) {
          // ensure the json data is an array
          if (!jsonObj.get("instanceMessages").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `instanceMessages` to be an array in the JSON string but got `%s`", jsonObj.get("instanceMessages").toString()));
          }

          // validate the optional field `instanceMessages` (array)
          for (int i = 0; i < jsonArrayinstanceMessages.size(); i++) {
            InstanceMessage.validateJsonElement(jsonArrayinstanceMessages.get(i));
          };
        }
      }
      // validate the optional field `maintenancePolicy`
      if (jsonObj.get("maintenancePolicy") != null && !jsonObj.get("maintenancePolicy").isJsonNull()) {
        GoogleCloudMemcacheV1beta2MaintenancePolicy.validateJsonElement(jsonObj.get("maintenancePolicy"));
      }
      // validate the optional field `maintenanceSchedule`
      if (jsonObj.get("maintenanceSchedule") != null && !jsonObj.get("maintenanceSchedule").isJsonNull()) {
        MaintenanceSchedule.validateJsonElement(jsonObj.get("maintenanceSchedule"));
      }
      if ((jsonObj.get("memcacheFullVersion") != null && !jsonObj.get("memcacheFullVersion").isJsonNull()) && !jsonObj.get("memcacheFullVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `memcacheFullVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("memcacheFullVersion").toString()));
      }
      if (jsonObj.get("memcacheNodes") != null && !jsonObj.get("memcacheNodes").isJsonNull()) {
        JsonArray jsonArraymemcacheNodes = jsonObj.getAsJsonArray("memcacheNodes");
        if (jsonArraymemcacheNodes != null) {
          // ensure the json data is an array
          if (!jsonObj.get("memcacheNodes").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `memcacheNodes` to be an array in the JSON string but got `%s`", jsonObj.get("memcacheNodes").toString()));
          }

          // validate the optional field `memcacheNodes` (array)
          for (int i = 0; i < jsonArraymemcacheNodes.size(); i++) {
            Node.validateJsonElement(jsonArraymemcacheNodes.get(i));
          };
        }
      }
      if ((jsonObj.get("memcacheVersion") != null && !jsonObj.get("memcacheVersion").isJsonNull()) && !jsonObj.get("memcacheVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `memcacheVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("memcacheVersion").toString()));
      }
      // validate the optional field `memcacheVersion`
      if (jsonObj.get("memcacheVersion") != null && !jsonObj.get("memcacheVersion").isJsonNull()) {
        MemcacheVersionEnum.validateJsonElement(jsonObj.get("memcacheVersion"));
      }
      if ((jsonObj.get("name") != null && !jsonObj.get("name").isJsonNull()) && !jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `nodeConfig`
      if (jsonObj.get("nodeConfig") != null && !jsonObj.get("nodeConfig").isJsonNull()) {
        NodeConfig.validateJsonElement(jsonObj.get("nodeConfig"));
      }
      // validate the optional field `parameters`
      if (jsonObj.get("parameters") != null && !jsonObj.get("parameters").isJsonNull()) {
        MemcacheParameters.validateJsonElement(jsonObj.get("parameters"));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("reservedIpRangeId") != null && !jsonObj.get("reservedIpRangeId").isJsonNull() && !jsonObj.get("reservedIpRangeId").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `reservedIpRangeId` to be an array in the JSON string but got `%s`", jsonObj.get("reservedIpRangeId").toString()));
      }
      if ((jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) && !jsonObj.get("state").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `state` to be a primitive type in the JSON string but got `%s`", jsonObj.get("state").toString()));
      }
      // validate the optional field `state`
      if (jsonObj.get("state") != null && !jsonObj.get("state").isJsonNull()) {
        StateEnum.validateJsonElement(jsonObj.get("state"));
      }
      if ((jsonObj.get("updateTime") != null && !jsonObj.get("updateTime").isJsonNull()) && !jsonObj.get("updateTime").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `updateTime` to be a primitive type in the JSON string but got `%s`", jsonObj.get("updateTime").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("zones") != null && !jsonObj.get("zones").isJsonNull() && !jsonObj.get("zones").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `zones` to be an array in the JSON string but got `%s`", jsonObj.get("zones").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Instance.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Instance' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Instance> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Instance.class));

       return (TypeAdapter<T>) new TypeAdapter<Instance>() {
           @Override
           public void write(JsonWriter out, Instance value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Instance read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Instance given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Instance
   * @throws IOException if the JSON string is invalid with respect to Instance
   */
  public static Instance fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Instance.class);
  }

  /**
   * Convert an instance of Instance to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

